<div id="root"></div>

<script src="https://cdn.tailwindcss.com"></script>
<script src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<script type="text/babel">
    const { useState, useRef, useEffect, useCallback } = React;

    const KDPCoverGenerator = () => {
        const [format, setFormat] = useState('');
        const [paperType, setPaperType] = useState('white');
        const [bindingType, setBindingType] = useState('paperback');
        const [coverFinish, setCoverFinish] = useState('matte');
        const [hasBleed, setHasBleed] = useState(false);
        const [pageCount, setPageCount] = useState(100);
        const [isExporting, setIsExporting] = useState(false);
        const [title, setTitle] = useState('');
        const [author, setAuthor] = useState('');
        const [spineText, setSpineText] = useState('');
        const [frontImage, setFrontImage] = useState(null);
        const [backImage, setBackImage] = useState(null);
        const [spineImage, setSpineImage] = useState(null);
        const [dimensions, setDimensions] = useState(null);
        const [warnings, setWarnings] = useState([]);
        const canvasRef = useRef(null);

        // Formats KDP officiels COMPLETS avec dimensions exactes
        const kdpFormats = {
            // Tailles de coupe standard les plus courantes - Broch√©
            '5x8': { width: 127, height: 203.2, name: '12,7 √ó 20,32 cm (5" √ó 8")', binding: ['paperback'], popular: true },
            '5.25x8': { width: 133.4, height: 203.2, name: '13,34 √ó 20,32 cm (5,25" √ó 8")', binding: ['paperback'], popular: true },
            '5.5x8.5': { width: 139.7, height: 215.9, name: '13,97 √ó 21,59 cm (5,5" √ó 8,5")', binding: ['paperback'], popular: true },
            '6x9': { width: 152.4, height: 228.6, name: '15,24 √ó 22,86 cm (6" √ó 9") ‚≠ê', binding: ['paperback'], popular: true },
            
            // Autres tailles de coupe standard - Broch√©
            '5.06x7.81': { width: 128.5, height: 198.4, name: '12,85 √ó 19,84 cm (5,06" √ó 7,81")', binding: ['paperback'] },
            '6.14x9.21': { width: 156, height: 233.9, name: '15,6 √ó 23,39 cm (6,14" √ó 9,21")', binding: ['paperback'] },
            '6.69x9.61': { width: 169.9, height: 244, name: '16,99 √ó 24,4 cm (6,69" √ó 9,61")', binding: ['paperback'] },
            '7x10': { width: 177.8, height: 254, name: '17,78 √ó 25,4 cm (7" √ó 10")', binding: ['paperback'] },
            '7.44x9.69': { width: 189, height: 246.1, name: '18,9 √ó 24,61 cm (7,44" √ó 9,69")', binding: ['paperback'] },
            '7.5x9.25': { width: 190.5, height: 235, name: '19,05 √ó 23,5 cm (7,5" √ó 9,25")', binding: ['paperback'] },
            '8x10': { width: 203.2, height: 254, name: '20,32 √ó 25,4 cm (8" √ó 10")', binding: ['paperback'] },
            '8.5x11': { width: 215.9, height: 279.4, name: '21,59 √ó 27,94 cm (8,5" √ó 11")', binding: ['paperback'] },
            
            // Formats livre reli√© - Tailles officielles KDP
            '5.5x8.5-hc': { width: 139.7, height: 215.9, name: '13,97 √ó 21,59 cm (5,5" √ó 8,5") - Reli√©', binding: ['hardcover'] },
            '6x9-hc': { width: 152.4, height: 228.6, name: '15,24 √ó 22,86 cm (6" √ó 9") - Reli√© ‚≠ê', binding: ['hardcover'], popular: true },
            '6.14x9.21-hc': { width: 156, height: 233.9, name: '15,6 √ó 23,39 cm (6,14" √ó 9,21") - Reli√©', binding: ['hardcover'] },
            '7x10-hc': { width: 177.8, height: 254, name: '17,78 √ó 25,4 cm (7" √ó 10") - Reli√©', binding: ['hardcover'] },
            '8.25x11-hc': { width: 209.5, height: 279.4, name: '20,95 √ó 27,94 cm (8,25" √ó 11") - Reli√©', binding: ['hardcover'] }
        };

        // Types de papier avec √©paisseur par page selon reliure
        const paperThickness = {
            paperback: {
                white: 0.0025, // 0.0025" par page pour papier blanc broch√©
                cream: 0.0025, // 0.0025" par page pour papier cr√®me broch√©
                color_standard: 0.004, // 0.004" par page pour papier couleur standard broch√©
                color_premium: 0.004   // 0.004" par page pour papier couleur premium broch√©
            },
            hardcover: {
                white: 0.0025, // 0.0025" par page pour papier blanc reli√©
                cream: 0.0025, // 0.0025" par page pour papier cr√®me reli√©
                color: 0.0025  // 0.0025" par page pour papier couleur premium reli√©
            }
        };

        // Options papier selon reliure avec descriptions compl√®tes
        const paperOptions = {
            paperback: [
                { value: 'white', label: 'Int√©rieur noir et blanc avec papier blanc ‚≠ê', description: 'G√©n√©ralement pour les ≈ìuvres de non-fiction ‚Ä¢ Grammage : 74-90 g/m¬≤' },
                { value: 'cream', label: 'Int√©rieur noir et blanc avec papier cr√®me', description: 'Id√©al pour romans et fiction ‚Ä¢ Lecture plus douce' },
                { value: 'color_standard', label: 'Int√©rieur couleur standard avec papier blanc', description: 'Co√ªt mod√©r√© ‚Ä¢ Qualit√© standard' },
                { value: 'color_premium', label: 'Int√©rieur couleur premium avec papier blanc', description: 'Qualit√© sup√©rieure ‚Ä¢ Co√ªt plus √©lev√©' }
            ],
            hardcover: [
                { value: 'white', label: 'Int√©rieur noir et blanc avec papier blanc ‚≠ê', description: 'Option la plus courante pour livres reli√©s' },
                { value: 'cream', label: 'Int√©rieur noir et blanc avec papier cr√®me', description: 'Alternative √©l√©gante au papier blanc' },
                { value: 'color', label: 'Int√©rieur couleur premium avec papier blanc', description: 'Qualit√© sup√©rieure ‚Ä¢ Co√ªt plus √©lev√©' }
            ]
        };

        // Options finition couverture avec descriptions
        const coverFinishOptions = [
            { value: 'matte', label: 'Mat ‚≠ê', description: 'Finition non r√©fl√©chissante ‚Ä¢ Plus r√©sistant aux traces' },
            { value: 'glossy', label: 'Brillant', description: 'Finition r√©fl√©chissante ‚Ä¢ Couleurs plus vives' }
        ];

        // Calcul des dimensions selon contraintes Amazon KDP
        const calculateDimensions = () => {
            if (!format || !pageCount || !bindingType) return null;

            const formatData = kdpFormats[format];
            if (!formatData || !formatData.binding.includes(bindingType)) return null;

            const spineWidth = pageCount * paperThickness[bindingType][paperType] * 25.4;
            let bleed = 0;
            if (hasBleed) {
                bleed = bindingType === 'hardcover' ? 6.35 : 3.175;
            }

            if (bindingType === 'hardcover') {
                return {
                    format: formatData,
                    spine: 0,
                    total: { width: formatData.width + (bleed * 2), height: formatData.height + (bleed * 2) },
                    bleed,
                    safeZone: hasBleed ? 12.7 : 6.35,
                    barcodeZone: { width: 51, height: 23 },
                    bindingType: 'hardcover',
                    hasBleed
                };
            }

            const totalWidth = (formatData.width * 2) + spineWidth + (bleed * 2);
            const totalHeight = formatData.height + (bleed * 2);

            return {
                format: formatData,
                spine: spineWidth,
                total: { width: totalWidth, height: totalHeight },
                bleed,
                safeZone: hasBleed ? 6.35 : 3.175,
                barcodeZone: { width: 51, height: 23 },
                bindingType: 'paperback',
                hasBleed
            };
        };

        // Validation et warnings selon contraintes Amazon KDP
        const validateSettings = () => {
            const newWarnings = [];
            
            // Contraintes pages selon reliure
            if (pageCount < 24) {
                newWarnings.push({ type: 'error', message: 'Minimum 24 pages requis pour KDP' });
            }

            if (bindingType === 'hardcover' && pageCount < 75) {
                newWarnings.push({ type: 'error', message: 'Minimum 75 pages requis pour livre reli√©' });
            }

            if (bindingType === 'hardcover' && pageCount > 550) {
                newWarnings.push({ type: 'warning', message: 'Maximum 550 pages recommand√© pour livre reli√©' });
            }

            if (bindingType === 'paperback' && pageCount > 828) {
                newWarnings.push({ type: 'error', message: 'Maximum 828 pages pour livre broch√©' });
            }
            
            // Contraintes texte dos selon √©paisseur
            if (bindingType === 'paperback' && pageCount < 100 && spineText) {
                const spineWidthMM = dimensions?.spine || 0;
                newWarnings.push({ 
                    type: 'warning', 
                    message: `Texte dos d√©conseill√© : ${pageCount} pages = tranche de ${Math.round(spineWidthMM * 10) / 10}mm seulement. Recommand√© : 100+ pages pour texte lisible sur la tranche.` 
                });
            }

            if (dimensions && dimensions.bindingType === 'paperback' && dimensions.spine < 1.5) {
                newWarnings.push({ 
                    type: 'info', 
                    message: `Tranche tr√®s fine (${Math.round(dimensions.spine * 10) / 10}mm) : il est normal que la tranche soit peu visible dans l'aper√ßu.` 
                });
            }

            if (bindingType === 'hardcover' && spineText) {
                newWarnings.push({ type: 'info', message: 'Livre reli√© : texte dos g√©r√© automatiquement par Amazon' });
            }

            setWarnings(newWarnings);
        };

        // Upload d'image
        const handleImageUpload = (file, type) => {
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const imageData = {
                    file,
                    url: e.target.result,
                    width: 0,
                    height: 0
                };

                switch(type) {
                    case 'front': setFrontImage(imageData); break;
                    case 'back': setBackImage(imageData); break;
                    case 'spine': setSpineImage(imageData); break;
                }
            };
            reader.readAsDataURL(file);
        };

        // Rendu aper√ßu (OPTIMIS√â)
        const drawPreview = useCallback(() => {
            if (!dimensions || !canvasRef.current) return;

            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');
            const scale = Math.min(400 / dimensions.total.width, 300 / dimensions.total.height);

            canvas.width = dimensions.total.width * scale;
            canvas.height = dimensions.total.height * scale;

            // Fond blanc
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Bordure
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);

            if (dimensions.bindingType === 'paperback') {
                const frontWidth = dimensions.format.width * scale;
                const spineWidth = dimensions.spine * scale;
                const bleedMargin = dimensions.bleed * scale;

                // Lignes de division
                ctx.strokeStyle = '#888888';
                ctx.lineWidth = 1;

                // Ligne verso/dos
                ctx.beginPath();
                ctx.moveTo(bleedMargin + frontWidth, 0);
                ctx.lineTo(bleedMargin + frontWidth, canvas.height);
                ctx.stroke();

                // Ligne dos/face
                ctx.beginPath();
                ctx.moveTo(bleedMargin + frontWidth + spineWidth, 0);
                ctx.lineTo(bleedMargin + frontWidth + spineWidth, canvas.height);
                ctx.stroke();

                // Images
                if (frontImage?.url) {
                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    img.onload = () => {
                        try {
                            ctx.drawImage(img, 
                                bleedMargin + frontWidth + spineWidth,
                                bleedMargin,
                                frontWidth,
                                dimensions.format.height * scale
                            );
                        } catch (e) {
                            console.log('Erreur affichage image face:', e);
                        }
                    };
                    img.src = frontImage.url;
                }

                if (backImage?.url) {
                    const img = new Image();
                    img.crossOrigin = "anonymous";
                    img.onload = () => {
                        try {
                            ctx.drawImage(img, 
                                bleedMargin,
                                bleedMargin,
                                frontWidth,
                                dimensions.format.height * scale
                            );
                        } catch (e) {
                            console.log('Erreur affichage image verso:', e);
                        }
                    };
                    img.src = backImage.url;
                }

                // Labels
                ctx.fillStyle = '#333333';
                ctx.font = `${Math.max(10, 12 * scale)}px Arial`;
                ctx.textAlign = 'center';
                
                ctx.fillText('VERSO', bleedMargin + frontWidth / 2, 20);
                if (spineWidth > 30) {
                    ctx.fillText('DOS', bleedMargin + frontWidth + spineWidth / 2, 20);
                }
                ctx.fillText('FACE', bleedMargin + frontWidth + spineWidth + frontWidth / 2, 20);

                // Titre et auteur sur la face
                if (title || author) {
                    ctx.font = `${Math.max(12, 16 * scale)}px Arial`;
                    const faceCenter = bleedMargin + frontWidth + spineWidth + frontWidth / 2;
                    
                    if (title) {
                        ctx.fillText(title, faceCenter, canvas.height / 2 - 20);
                    }
                    
                    if (author) {
                        ctx.fillText(author, faceCenter, canvas.height / 2 + 20);
                    }
                }

                // Texte dos (vertical) - AJOUT√â
                if (spineText && spineWidth > 20 && dimensions.bindingType === 'paperback') {
                    ctx.save();
                    ctx.translate(bleedMargin + frontWidth + spineWidth / 2, canvas.height / 2);
                    ctx.rotate(-Math.PI / 2);
                    ctx.fillStyle = '#333333';
                    ctx.font = `${Math.max(8, 10 * scale)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(spineText, 0, 0);
                    ctx.restore();
                }
            }

            // Info dimensions
            ctx.fillStyle = '#666666';
            ctx.font = `${Math.max(8, 10 * scale)}px Arial`;
            ctx.textAlign = 'left';
            ctx.fillText(`${Math.round(dimensions.total.width)}√ó${Math.round(dimensions.total.height)}mm`, 5, canvas.height - 5);

        }, [dimensions, frontImage, backImage, title, author, spineText]);

        // Export RAPIDE
        const exportImage = () => {
            if (!dimensions) {
                alert('Veuillez d\'abord s√©lectionner un format');
                return;
            }

            setIsExporting(true);

            setTimeout(() => {
                try {
                    const canvas = canvasRef.current;
                    const link = document.createElement('a');
                    link.download = `couverture-kdp-${format}-${pageCount}pages.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();

                    const finishText = ` - Finition ${coverFinish === 'matte' ? 'mat' : 'brillant'}`;
                    const paperText = paperOptions[bindingType].find(p => p.value === paperType)?.label.replace(' ‚≠ê', '');
                    const bleedText = hasBleed ? ' - Avec fond perdu' : ' - Sans fond perdu';
                    
                    alert(`‚úÖ Image g√©n√©r√©e avec succ√®s !\n\nFormat: ${kdpFormats[format].name}\nDimensions: ${Math.round(dimensions.total.width)}√ó${Math.round(dimensions.total.height)}mm\nPapier: ${paperText}${finishText}${bleedText}\n\nüìÅ Fichier t√©l√©charg√© haute r√©solution\nüöÄ Pr√™t pour Amazon KDP !`);
                } catch (error) {
                    alert('‚ùå Erreur lors de l\'export: ' + error.message);
                } finally {
                    setIsExporting(false);
                }
            }, 100);
        };

        useEffect(() => {
            const newDimensions = calculateDimensions();
            setDimensions(newDimensions);
            if (format && kdpFormats[format] && !kdpFormats[format].binding.includes(bindingType)) {
                setFormat('');
            }
            if (!paperOptions[bindingType].find(p => p.value === paperType)) {
                setPaperType('white');
            }
        }, [format, pageCount, paperType, bindingType, hasBleed]);

        useEffect(() => {
            validateSettings();
        }, [pageCount, spineText, dimensions, bindingType]);

        useEffect(() => {
            drawPreview();
        }, [drawPreview]);

        return (
            <div className="min-h-screen bg-gray-50 p-4">
                <div className="max-w-6xl mx-auto">
                    {/* Header */}
                    <div className="bg-white rounded-lg shadow-sm p-6 mb-6">
                        <div className="flex items-center space-x-3 mb-4">
                            <span className="text-2xl">üìö</span>
                            <h1 className="text-3xl font-bold text-gray-900">G√©n√©rateur de Couvertures KDP</h1>
                        </div>
                        <p className="text-gray-600">De Canva √† KDP en 3 clics - Dimensions parfaites garanties</p>
                    </div>

                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        {/* Param√®tres */}
                        <div className="space-y-6">
                            <div className="bg-white rounded-lg shadow-sm p-6">
                                <h2 className="text-xl font-semibold mb-4">Param√®tres du livre</h2>
                                
                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">Type de reliure</label>
                                        <select 
                                            value={bindingType} 
                                            onChange={(e) => setBindingType(e.target.value)}
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                                        >
                                            <option value="paperback">Livre broch√© (Paperback)</option>
                                            <option value="hardcover">Livre reli√© (Hardcover)</option>
                                        </select>
                                    </div>

                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">Format KDP</label>
                                        <select 
                                            value={format} 
                                            onChange={(e) => setFormat(e.target.value)}
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                                        >
                                            <option value="">S√©lectionner un format</option>
                                            
                                            {/* Formats populaires d'abord */}
                                            {bindingType === 'paperback' && (
                                                <optgroup label="üìà Tailles les plus courantes">
                                                    {Object.entries(kdpFormats)
                                                        .filter(([key, data]) => data.binding.includes(bindingType) && data.popular)
                                                        .map(([key, data]) => (
                                                            <option key={key} value={key}>{data.name}</option>
                                                        ))}
                                                </optgroup>
                                            )}
                                            
                                            <optgroup label={bindingType === 'paperback' ? "üìö Autres tailles standard" : "üìñ Formats livre reli√©"}>
                                                {Object.entries(kdpFormats)
                                                    .filter(([key, data]) => data.binding.includes(bindingType) && !data.popular)
                                                    .map(([key, data]) => (
                                                        <option key={key} value={key}>{data.name}</option>
                                                    ))}
                                            </optgroup>
                                        </select>
                                        <p className="text-xs text-gray-500 mt-1">
                                            ‚≠ê = Format le plus populaire sur KDP
                                        </p>
                                    </div>

                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">Nombre de pages</label>
                                        <input 
                                            type="number" 
                                            value={pageCount}
                                            onChange={(e) => setPageCount(parseInt(e.target.value) || 0)}
                                            min={bindingType === 'hardcover' ? 75 : 24}
                                            max={bindingType === 'hardcover' ? 550 : 828}
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                                        />
                                        <p className="text-xs text-gray-500 mt-1">
                                            {bindingType === 'hardcover' 
                                                ? '75 √† 550 pages pour livre reli√©' 
                                                : '24 √† 828 pages pour livre broch√©'}
                                        </p>
                                    </div>

                                    <div>
                                        <label className="flex items-center space-x-2">
                                            <input
                                                type="checkbox"
                                                checked={hasBleed}
                                                onChange={(e) => setHasBleed(e.target.checked)}
                                                className="rounded"
                                            />
                                            <span className="text-sm">Fond perdu (images jusqu'au bord)</span>
                                        </label>
                                    </div>

                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">Type d'encre et de papier</label>
                                        <select 
                                            value={paperType} 
                                            onChange={(e) => setPaperType(e.target.value)}
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                                        >
                                            {paperOptions[bindingType].map(option => (
                                                <option key={option.value} value={option.value}>
                                                    {option.label}
                                                </option>
                                            ))}
                                        </select>
                                        <p className="text-xs text-gray-500 mt-1">
                                            {paperOptions[bindingType].find(p => p.value === paperType)?.description}
                                        </p>
                                    </div>

                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">Finition de la couverture</label>
                                        <select 
                                            value={coverFinish} 
                                            onChange={(e) => setCoverFinish(e.target.value)}
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                                        >
                                            {coverFinishOptions.map(option => (
                                                <option key={option.value} value={option.value}>
                                                    {option.label}
                                                </option>
                                            ))}
                                        </select>
                                        <p className="text-xs text-gray-500 mt-1">
                                            {coverFinishOptions.find(f => f.value === coverFinish)?.description}
                                        </p>
                                    </div>

                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">Titre du livre</label>
                                        <input 
                                            type="text" 
                                            value={title}
                                            onChange={(e) => setTitle(e.target.value)}
                                            placeholder="Titre principal"
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                                        />
                                    </div>

                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">Auteur</label>
                                        <input 
                                            type="text" 
                                            value={author}
                                            onChange={(e) => setAuthor(e.target.value)}
                                            placeholder="Nom de l'auteur"
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                                        />
                                    </div>

                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">Texte du dos (tranche)</label>
                                        <input 
                                            type="text" 
                                            value={spineText}
                                            onChange={(e) => setSpineText(e.target.value)}
                                            placeholder={bindingType === 'hardcover' ? 'G√©r√© automatiquement par Amazon' : dimensions && dimensions.spine < 1.5 ? 'Tranche trop fine - non recommand√©' : 'Titre ou auteur (optionnel)'}
                                            disabled={bindingType === 'hardcover' || (dimensions && dimensions.spine < 1.5)}
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 disabled:bg-gray-100"
                                        />
                                        {bindingType === 'hardcover' ? (
                                            <p className="text-xs text-gray-500 mt-1">Livre reli√© : texte dos g√©r√© par Amazon</p>
                                        ) : dimensions && dimensions.spine < 1.5 ? (
                                            <p className="text-xs text-orange-600 mt-1">
                                                Tranche de {Math.round(dimensions.spine * 10) / 10}mm trop fine pour du texte.
                                            </p>
                                        ) : (
                                            <p className="text-xs text-gray-500 mt-1">Recommand√© : 100+ pages pour texte lisible sur la tranche</p>
                                        )}
                                    </div>

                                    {dimensions && (
                                        <div className="bg-blue-50 p-4 rounded-lg">
                                            <h3 className="font-medium text-blue-900 mb-2">üìê Dimensions calcul√©es</h3>
                                            <div className="text-sm text-blue-800 space-y-1">
                                                <div>Type: {dimensions.bindingType === 'hardcover' ? 'Livre reli√©' : 'Livre broch√©'}</div>
                                                <div>Finition: {coverFinish === 'matte' ? 'Mat' : 'Brillant'}</div>
                                                <div>Fond perdu: {hasBleed ? 'Oui' : 'Non'}</div>
                                                <div><strong>Largeur totale: {Math.round(dimensions.total.width * 10) / 10} mm</strong></div>
                                                <div><strong>Hauteur totale: {Math.round(dimensions.total.height * 10) / 10} mm</strong></div>
                                                {dimensions.bindingType === 'paperback' && (
                                                    <div>
                                                        √âpaisseur dos: {Math.round(dimensions.spine * 10) / 10} mm
                                                        {dimensions.spine < 1.5 && (
                                                            <span className="text-orange-600 ml-2">(tranche fine)</span>
                                                        )}
                                                    </div>
                                                )}
                                                <div className="pt-1 border-t border-blue-200">
                                                    <div>Format page: {dimensions.format.width} √ó {dimensions.format.height} mm</div>
                                                    <div>Papier: {paperOptions[bindingType].find(p => p.value === paperType)?.label.replace(' ‚≠ê', '')}</div>
                                                    {hasBleed && <div>Fond perdu: {dimensions.bleed} mm</div>}
                                                    <div>Zone s√©curit√©: {dimensions.safeZone} mm</div>
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>

                            {/* Upload images */}
                            <div className="bg-white rounded-lg shadow-sm p-6">
                                <h2 className="text-xl font-semibold mb-4">üìÅ Images</h2>
                                
                                <div className="space-y-4">
                                    {/* Image Face */}
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">Image Face (1√®re de couverture)</label>
                                        <input
                                            type="file"
                                            accept="image/*"
                                            onChange={(e) => handleImageUpload(e.target.files[0], 'front')}
                                            className="w-full p-2 border border-gray-300 rounded-lg"
                                        />
                                        {frontImage && (
                                            <div className="mt-2">
                                                <img src={frontImage.url} alt="Face" className="w-20 h-20 object-cover rounded" />
                                            </div>
                                        )}
                                    </div>

                                    {/* Image Verso */}
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">Image Verso (4√®me de couverture)</label>
                                        <input
                                            type="file"
                                            accept="image/*"
                                            onChange={(e) => handleImageUpload(e.target.files[0], 'back')}
                                            className="w-full p-2 border border-gray-300 rounded-lg"
                                        />
                                        {backImage && (
                                            <div className="mt-2">
                                                <img src={backImage.url} alt="Verso" className="w-20 h-20 object-cover rounded" />
                                            </div>
                                        )}
                                    </div>

                                    {/* Image Dos */}
                                    {bindingType === 'paperback' && (
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700 mb-2">Image Dos (tranche) - Optionnel</label>
                                            <input
                                                type="file"
                                                accept="image/*"
                                                onChange={(e) => handleImageUpload(e.target.files[0], 'spine')}
                                                className="w-full p-2 border border-gray-300 rounded-lg"
                                                disabled={dimensions && dimensions.spine < 1.5}
                                            />
                                            {spineImage && (
                                                <div className="mt-2">
                                                    <img src={spineImage.url} alt="Dos" className="w-20 h-20 object-cover rounded" />
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>

                        {/* Aper√ßu et Export */}
                        <div className="space-y-6">
                            <div className="bg-white rounded-lg shadow-sm p-6">
                                <div className="flex items-center justify-between mb-4">
                                    <h2 className="text-xl font-semibold">üëÅÔ∏è Aper√ßu</h2>
                                    <button
                                        onClick={exportImage}
                                        disabled={!dimensions || isExporting}
                                        className={`flex items-center space-x-2 px-6 py-3 rounded-lg font-bold transition-colors ${
                                            isExporting 
                                                ? 'bg-orange-500 text-white cursor-wait' 
                                                : !dimensions
                                                ? 'bg-gray-400 text-white cursor-not-allowed'
                                                : 'bg-green-600 text-white hover:bg-green-700'
                                        }`}
                                    >
                                        <span className="text-lg">üíæ</span>
                                        <span>{isExporting ? 'G√©n√©ration...' : 'üöÄ CR√âER COUVERTURE'}</span>
                                    </button>
                                </div>
                                
                                <div className="border rounded-lg overflow-hidden bg-gray-100 p-4">
                                    <canvas 
                                        ref={canvasRef}
                                        className="max-w-full h-auto border"
                                        style={{ maxHeight: '400px', display: 'block', margin: '0 auto' }}
                                    />
                                </div>

                                <div className="mt-4 bg-green-50 p-4 rounded-lg">
                                    <div className="flex items-center space-x-2 mb-2">
                                        <span className="text-lg">‚úÖ</span>
                                        <span className="font-medium text-green-800">Outil COMPLET fonctionnel !</span>
                                    </div>
                                    <ul className="text-sm text-green-700 space-y-1">
                                        <li>‚úÖ <strong>TOUS les formats KDP</strong> (17 formats)</li>
                                        <li>‚úÖ <strong>Texte sur la tranche</strong> fonctionnel</li>
                                        <li>‚úÖ <strong>Contraintes Amazon</strong> respect√©es</li>
                                        <li>‚úÖ <strong>Export haute r√©solution</strong></li>
                                        <li>üöÄ <strong>Pr√™t pour Amazon KDP</strong></li>
                                    </ul>
                                </div>

                                <div className="mt-4 p-4 bg-blue-50 rounded-lg">
                                    <h4 className="font-medium text-blue-800 mb-2">üí° Workflow complet :</h4>
                                    <ol className="text-sm text-blue-700 space-y-1">
                                        <li>1. <strong>Cr√©ez</strong> vos designs sur Canva</li>
                                        <li>2. <strong>Configurez</strong> tous les param√®tres</li>
                                        <li>3. <strong>Uploadez</strong> vos images</li>
                                        <li>4. <strong>Ajoutez</strong> texte sur tranche si besoin</li>
                                        <li>5. <strong>Exportez</strong> et uploadez sur KDP !</li>
                                    </ol>
                                </div>
                            </div>

                            {/* Warnings */}
                            {warnings.length > 0 && (
                                <div className="bg-white rounded-lg shadow-sm p-6">
                                    <h3 className="font-semibold mb-3">‚ö†Ô∏è Validation KDP</h3>
                                    <div className="space-y-2">
                                        {warnings.map((warning, index) => (
                                            <div 
                                                key={index} 
                                                className={`p-3 rounded-lg text-sm ${
                                                    warning.type === 'error' 
                                                        ? 'bg-red-50 text-red-800' 
                                                        : warning.type === 'warning'
                                                        ? 'bg-amber-50 text-amber-800'
                                                        : 'bg-blue-50 text-blue-800'
                                                }`}
                                            >
                                                {warning.message}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            </div>
        );
    };

    ReactDOM.render(<KDPCoverGenerator />, document.getElementById('root'));
</script>
